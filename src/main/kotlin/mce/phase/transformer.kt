package mce.phase

import mce.ast.core.Entry
import mce.ast.core.Parameter
import mce.ast.core.Term
import mce.util.toLinkedHashMap

inline fun Term.map(transform: (Term) -> Term): Term = when (this) {
    is Term.Hole -> Term.Hole(id)
    is Term.Meta -> Term.Meta(index, id)
    is Term.Var -> Term.Var(name, level, id)
    is Term.Def -> Term.Def(name, arguments.map(transform), id)
    is Term.Let -> Term.Let(name, transform(init), transform(body), id)
    is Term.Match -> Term.Match(transform(scrutinee), clauses.map { it.first to transform(it.second) }, id)
    is Term.UnitOf -> Term.UnitOf(id)
    is Term.BoolOf -> Term.BoolOf(value, id)
    is Term.ByteOf -> Term.ByteOf(value, id)
    is Term.ShortOf -> Term.ShortOf(value, id)
    is Term.IntOf -> Term.IntOf(value, id)
    is Term.LongOf -> Term.LongOf(value, id)
    is Term.FloatOf -> Term.FloatOf(value, id)
    is Term.DoubleOf -> Term.DoubleOf(value, id)
    is Term.StringOf -> Term.StringOf(value, id)
    is Term.ByteArrayOf -> Term.ByteArrayOf(elements.map(transform), id)
    is Term.IntArrayOf -> Term.IntArrayOf(elements.map(transform), id)
    is Term.LongArrayOf -> Term.LongArrayOf(elements.map(transform), id)
    is Term.ListOf -> Term.ListOf(elements.map(transform), id)
    is Term.CompoundOf -> Term.CompoundOf(elements.map { (name, element) -> name to transform(element) }.toLinkedHashMap(), id)
    is Term.BoxOf -> Term.BoxOf(transform(content), transform(tag), id)
    is Term.RefOf -> Term.RefOf(transform(element), id)
    is Term.Refl -> Term.Refl(id)
    is Term.FunOf -> Term.FunOf(parameters, transform(body), id)
    is Term.Apply -> Term.Apply(transform(function), arguments.map(transform), id)
    is Term.CodeOf -> Term.CodeOf(transform(element), id)
    is Term.Splice -> Term.Splice(transform(element), id)
    is Term.Or -> Term.Or(variants.map(transform), id)
    is Term.And -> Term.And(variants.map(transform), id)
    is Term.Unit -> Term.Unit(id)
    is Term.Bool -> Term.Bool(id)
    is Term.Byte -> Term.Byte(id)
    is Term.Short -> Term.Short(id)
    is Term.Int -> Term.Int(id)
    is Term.Long -> Term.Long(id)
    is Term.Float -> Term.Float(id)
    is Term.Double -> Term.Double(id)
    is Term.String -> Term.String(id)
    is Term.ByteArray -> Term.ByteArray(id)
    is Term.IntArray -> Term.IntArray(id)
    is Term.LongArray -> Term.LongArray(id)
    is Term.List -> Term.List(transform(element), transform(size), id)
    is Term.Compound -> Term.Compound(elements.map { (name, element) -> name to Entry(element.relevant, transform(element.type), element.id) }.toLinkedHashMap(), id)
    is Term.Box -> Term.Box(transform(content), id)
    is Term.Ref -> Term.Ref(transform(element), id)
    is Term.Eq -> Term.Eq(transform(left), transform(right), id)
    is Term.Fun -> Term.Fun(parameters.map { Parameter(it.termRelevant, it.name, it.lower?.let(transform), it.upper?.let(transform), it.typeRelevant, transform(it.type), it.id) }, transform(resultant), effects, id)
    is Term.Code -> Term.Code(transform(element), id)
    is Term.Type -> Term.Type(id)
}
